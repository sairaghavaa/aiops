from flask import Flask, render_template, request, redirect, url_for, flash, session
import requests
import os
from datetime import datetime

app = Flask(__name__)
app.secret_key = os.urandom(16)

# Placeholder for user storage (consider using a database in production)
users = {'admin': 'password'}
roles = {'admin': 'DevOps', 'performance_tester': 'Performance Tester'}

env = None
START_CONTAINER_URL = None
STOP_CONTAINER_URL = None
LIST_IMAGES_URL = None
WHITELIST_IP_API_URL = None
SCALE_CONTAINERS_URL = None

# Authentication Service URLs
AUTH_SERVICE_LOGIN_URL = "https://your-auth-service.com/login"
AUTH_SERVICE_VALIDATE_TOKEN_URL = "https://your-auth-service.com/validate_token"

INDEX_HTML = 'index.html'

ERROR_MESSAGE = 'You are not authorized to perform this action'
START_CONTAINER_MESSAGE = 'Starting container...'
STOP_CONTAINER_MESSAGE = 'Stopping container...'

@app.route('/')
def home():
    if 'username' in session:
        return redirect(url_for('dashboard'))
    return redirect(url_for('login'))

@app.route('/dashboard', methods=['GET'])
def dashboard():
    if 'dcp_token' not in session:
        return redirect(url_for('login'))

    # Check if the DCP token is still valid (optional)
    is_valid, user_info = validate_dcp_token(session['dcp_token'])

    if not is_valid:
        session.pop('dcp_token', None)
        return redirect(url_for('login'))

    functionalities = ['Start and Stop Services', 'Deployment History Overview', 'Whitelist IP', 'Autoscaling']
    return render_template('dashboard.html', functionalities=functionalities, user_info=user_info)

@app.route('/login', methods=['GET'])
def login():
    # Redirect the user to the authentication service's login page
    return redirect(AUTH_SERVICE_LOGIN_URL)

@app.route('/auth_callback', methods=['GET'])
def auth_callback():
    # Retrieve the DCP token from the authentication service's response
    dcp_token = request.args.get('dcp_token')

    if dcp_token:
        # Validate the DCP token with the authentication service
        is_valid, user_info = validate_dcp_token(dcp_token)

        if is_valid:
            # Store the DCP token and user information in the session
            session['dcp_token'] = dcp_token
            session['username'] = user_info['username']
            session['role'] = user_info['role']

            # Redirect the user to the dashboard or desired page
            return redirect(url_for('dashboard'))
        else:
            flash('Invalid DCP token')
    else:
        flash('Missing DCP token')

    return redirect(url_for('login'))

@app.route('/logout', methods=['GET'])
def logout():
    session.pop('dcp_token', None)
    session.pop('username', None)
    session.pop('role', None)
    return redirect(url_for('login'))

def validate_dcp_token(dcp_token):
    # Send the DCP token to the authentication service for validation
    response = requests.post(AUTH_SERVICE_VALIDATE_TOKEN_URL, json={"dcp_token": dcp_token})

    if response.status_code == 200:
        user_info = response.json()
        return True, user_info
    else:
        return False, None

# Rest of the code...

# Select Environment after Successful Login 
@app.route('/select_environment', methods=['GET', 'POST'])
def select_environment():
    if 'dcp_token' not in session:
        return redirect(url_for('login'))

    # Check if the DCP token is still valid (optional)
    is_valid, user_info = validate_dcp_token(session['dcp_token'])

    if not is_valid:
        session.pop('dcp_token', None)
        return redirect(url_for('login'))

    if request.method == 'POST':
        global env, START_CONTAINER_URL, STOP_CONTAINER_URL, LIST_IMAGES_URL, WHITELIST_IP_API_URL, SCALE_CONTAINERS_URL
        env = request.form['environment']
        if env == 'BF1':
            from config_bf1 import START_CONTAINER_URL, STOP_CONTAINER_URL, LIST_IMAGES_URL, WHITELIST_IP_API_URL, SCALE_CONTAINERS_URL
        elif env == 'BF2':
            from config_bf2 import START_CONTAINER_URL, STOP_CONTAINER_URL, LIST_IMAGES_URL, WHITELIST_IP_API_URL, SCALE_CONTAINERS_URL
        elif env == 'BF3':
            from config_bf3 import START_CONTAINER_URL, STOP_CONTAINER_URL, LIST_IMAGES_URL, WHITELIST_IP_API_URL, SCALE_CONTAINERS_URL
        else:
            flash('Invalid environment selected')
            return render_template('select_environment.html', user_info=user_info)
        return redirect(url_for('dashboard'))
    return render_template('select_environment.html', user_info=user_info)

@app.route('/manage_containers', methods=['GET'])
def manage_containers():
    if 'dcp_token' not in session:
        return redirect(url_for('login'))

    # Check if the DCP token is still valid (optional)
    is_valid, user_info = validate_dcp_token(session['dcp_token'])

    if not is_valid:
        session.pop('dcp_token', None)
        return redirect(url_for('login'))

    return render_template(INDEX_HTML, user_info=user_info)

@app.route('/start', methods=['POST'])
def start_container():
    if 'dcp_token' in session and START_CONTAINER_URL:
        # Check if the DCP token is still valid (optional)
        is_valid, user_info = validate_dcp_token(session['dcp_token'])

        if is_valid:
            response = requests.post(START_CONTAINER_URL, json={})
            if response.status_code == 200:
                flash(START_CONTAINER_MESSAGE)
            else:
                flash(f'Failed to start containers. Error: {response.text}')
        else:
            session.pop('dcp_token', None)
            flash(ERROR_MESSAGE)
    else:
        flash(ERROR_MESSAGE)

    return render_template(INDEX_HTML, user_info=user_info)

@app.route('/stop', methods=['POST'])
def stop_container():
    if 'dcp_token' in session and STOP_CONTAINER_URL:
        # Check if the DCP token is still valid (optional)
        is_valid, user_info = validate_dcp_token(session['dcp_token'])

        if is_valid:
            response = requests.post(STOP_CONTAINER_URL, json={})
            if response.status_code == 200:
                flash(STOP_CONTAINER_MESSAGE)
            else:
                flash(f'Failed to stop containers. Error: {response.text}')
        else:
            session.pop('dcp_token', None)
            flash(ERROR_MESSAGE)
    else:
        flash(ERROR_MESSAGE)

    return render_template(INDEX_HTML, user_info=user_info)

def is_new_image(image_pushed_at, threshold_hours=24):
    pushed_at_dt = datetime.strptime(image_pushed_at, "%Y-%m-%d %H:%M:%S")
    return (datetime.utcnow() - pushed_at_dt).total_seconds() < threshold_hours * 3600

@app.route('/list_images', methods=['GET'])
def list_images():
    if 'dcp_token' not in session:
        flash('Please log in to view the images.')
        return redirect(url_for('login'))

    # Check if the DCP token is still valid (optional)
    is_valid, user_info = validate_dcp_token(session['dcp_token'])

    if not is_valid:
        session.pop('dcp_token', None)
        return redirect(url_for('login'))

    try:
        response = requests.get(LIST_IMAGES_URL)
        if response.status_code == 200:
            images = response.json()
            images.sort(key=lambda x: x[0]['repositoryName'])
            for repository in images:
                repository.sort(key=lambda x: x['imagePushedAt'], reverse=True)
                for image in repository:
                    image['isNew'] = is_new_image(image['imagePushedAt'])
            return render_template('list_images.html', images=images, user_info=user_info)
        else:
            flash('Could not fetch images. Please try again.')
            return redirect(url_for('dashboard'))
    except requests.exceptions.RequestException as e:
        flash('An error occurred while trying to fetch images.')
        return redirect(url_for('dashboard'))

@app.route('/whitelist_ip', methods=['GET', 'POST'])
def whitelist_ip():
    if 'dcp_token' not in session:
        return redirect(url_for('login'))

    # Check if the DCP token is still valid (optional)
    is_valid, user_info = validate_dcp_token(session['dcp_token'])

    if not is_valid:
        session.pop('dcp_token', None)
        return redirect(url_for('login'))

    if request.method == 'POST':
        ip_address = request.form['ip_address']
        if ip_address:
            try:
                response = requests.post(WHITELIST_IP_API_URL, json={'ip_address': ip_address})
                response.raise_for_status()  # Raise an exception for non-2xx status codes
                flash(response.text)
            except requests.exceptions.RequestException as e:
                flash(f'An error occurred while whitelisting the IP address: {str(e)}')
        else:
            flash('Please enter a valid IP address.')
    return render_template('whitelist_ip.html', user_info=user_info)

@app.route('/autoscaling', methods=['GET', 'POST'])
def autoscaling():
    if 'dcp_token' not in session:
        return redirect(url_for('login'))

    # Check if the DCP token is still valid (optional)
    is_valid, user_info = validate_dcp_token(session['dcp_token'])

    if not is_valid:
        session.pop('dcp_token', None)
        return redirect(url_for('login'))

    if request.method == 'POST':
        action = request.form['action']
        num_instances = int(request.form['num_instances'])

        if action == 'Scale Up':
            max_instances = 12 if user_info['role'] == 'Performance Tester' else 4
            if num_instances > max_instances:
                flash(f'You are not allowed to scale up beyond {max_instances} instances.')
            else:
                try:
                    response = requests.post(SCALE_CONTAINERS_URL, json={'action': 'scale_up', 'num_instances': num_instances})
                    response.raise_for_status()  # Raise an exception for non-2xx status codes
                    flash(response.json()['body'])
                except requests.exceptions.RequestException as e:
                    flash(f'An error occurred while scaling up: {str(e)}')
        elif action == 'Scale Down':
            try:
                response = requests.post(SCALE_CONTAINERS_URL, json={'action': 'scale_down', 'num_instances': num_instances})
                response.raise_for_status()  # Raise an exception for non-2xx status codes
                flash(response.json()['body'])
            except requests.exceptions.RequestException as e:
                flash(f'An error occurred while scaling down: {str(e)}')
    return render_template('autoscaling.html', user_info=user_info)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)




    DCP stands for "Distributed Cloud Pointer," which is an approach to control access to your Python Flask application deployed on AWS ECS without whitelisting individual IP addresses. Here's how it works:

1. **User Authentication**: When a user tries to access your Flask application, they are redirected to an authentication service (e.g., your organization's Identity Provider or a custom authentication service).

2. **Token Generation**: Upon successful authentication, the authentication service generates a short-lived, cryptographically secure token called a Distributed Cloud Pointer (DCP).

3. **Token Delivery**: The DCP token is delivered to the user's browser or client application.

4. **Application Access**: When the user attempts to access your Flask application, they present the DCP token as part of the request (e.g., in an HTTP header or as a query parameter).

5. **Token Validation**: Your Flask application validates the DCP token by contacting the authentication service that issued the token. The authentication service confirms the token's validity and provides information about the authenticated user.

6. **Access Control**: Based on the user information provided by the authentication service, your Flask application can make authorization decisions and grant or deny access to specific resources or functionality.

7. **Token Expiration**: DCP tokens have a short lifespan (typically a few minutes or hours), after which they expire and become invalid. Users must reauthenticate to obtain a new DCP token.

The DCP approach provides several advantages:

- **No IP Whitelisting**: Since access is controlled by presenting a valid DCP token, there's no need to whitelist individual IP addresses.
- **Scalability**: The authentication service and your Flask application can scale independently, as they communicate via lightweight DCP tokens.
- **Security**: DCP tokens are short-lived and cryptographically secure, reducing the risk of token theft or misuse.
- **Flexibility**: You can integrate the DCP approach with various authentication providers, including your organization's existing Identity Provider.

However, implementing the DCP approach can be complex and may require significant development effort. It also introduces an additional dependency on the authentication service, which must be highly available and reliable. Additionally, you'll need to implement robust token validation and secure communication between your Flask application and the authentication service.

While the DCP approach is a viable solution, it's essential to carefully evaluate its complexity, security considerations, and compatibility with your organization's existing infrastructure and policies.